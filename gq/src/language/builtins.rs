use template_macros::{fragment, half_fragment};

use crate::language::builtin::{BracketHandler, Builtin, MultiOutputBehavior, OutputHandler};

use super::builtin::BracketContextFlags;

pub const BUILTINS: &'static [Builtin] = &[
    Builtin {
        name: "bracket",
        description: "no-op group",
        token: '(',
        template: fragment!(
            "
            const {wrapper:local} = function* () {{
                {inner}
            "
        ),
        bracket_handlers: &[BracketHandler {
            flags: BracketContextFlags::new(),
            output_handler: Some(OutputHandler {
                fragment: half_fragment!(
                    "
                        yield ({value:in});
                    "
                ),
                behavior: MultiOutputBehavior::FlattenAll,
            }),
            fragment: fragment!(
                "
                        //
                    }};
                    for ({output:out} of {wrapper:local}()) {{
                        {inner}
                    }}
                "
            ),
        }],
    },
    Builtin {
        name: "List wrap",
        description: "Create a list/array from the items generated by the enclosed generator.",
        token: '[',
        template: fragment!(
            "
            const {arr:local} = [];
            { inner }
        "
        ),
        bracket_handlers: &[BracketHandler {
            flags: BracketContextFlags::new(),
            output_handler: Some(OutputHandler {
                fragment: half_fragment!(
                    "
                        {arr:local}.push({value:in});
                        "
                ),
                behavior: MultiOutputBehavior::FlattenAll,
            }),
            fragment: fragment!(
                "
                    const {out:out} = {arr:local};
                    {inner}
                    "
            ),
        }],
    },
    Builtin {
        name: "If",
        description: "Pops one argument, executes the first block if true and the second if false",
        token: '?',
        template: fragment!(
            "
            const { condition:local } = to_bool({condition_var:in});

            const {if_true:local} = function* (){{
                {inner}
            "
        ),
        bracket_handlers: &[
            BracketHandler {
                flags: BracketContextFlags::new().set_no_pop(true),
                output_handler: None,
                fragment: fragment!(
                    "
                    //
                }}
                const {if_false:local} = function* (){{
                    {inner}
                }}
                "
                ),
            },
            BracketHandler {
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!(
                        "
                        yield [{value:in}];
                        "
                    ),
                    behavior: MultiOutputBehavior::Variadic,
                }),
                flags: BracketContextFlags::new(),
                fragment: fragment!(
                    "

                    const {generator:local} = ({condition:local})?{if_true:local}():{if_false:local}();
                    for ([{value:out}] of {generator:local}) {{
                        {inner}
                    }}
                "
                ),
            },
        ],
    },
    Builtin {
        name: "Reduce",
        description: "Pops an accumulator, then applies the second group to the items from the first group. Outputs the final accumulator.",
        token: 'R',
        template: fragment!(
            "
            let {accumulator:local} = {initial:in};
            
            const {inner:local} = () => {{
                {inner}
            
            "
        ),
        bracket_handlers: &[
            BracketHandler {
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!(
                        "
                            {next:local}({accumulator:local}, {value:in})
                            "
                    ),
                    behavior: MultiOutputBehavior::FlattenAll,
                }),
                flags: BracketContextFlags::new(),
                fragment: fragment!(
                    "
                    //
                }}

                const {next:local} = ({accumulator:out}, {value:out}) => {{
                    {inner}
                }}
                "
                ),
            },
            BracketHandler {
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!(
                        "
                        {accumulator:local} = {value:in};
                        "
                    ),
                    behavior: MultiOutputBehavior::OnlyFirst,
                }),
                flags: BracketContextFlags::new(),
                fragment: fragment!(
                    "
                {inner:local}();

                {out:out} = {accumulator:local};
                "
                ),
            },
        ],
    },
    Builtin {
        name: "range",
        description: "Outputs the numbers from 0 to N exclusive",
        token: 'r', // I might be able to make array unwrap on a number do range
        template: fragment!(
            "
            for (let {i:out}=0;{i:out}<{max:in};{i:out}++) {{
                {inner}
            }}
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "plus",
        description: "adds",
        token: '+',
        template: fragment!(
            "
            const {out:out} = add({op1:in}, {op2:in});
            { inner }
        "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "sub",
        description: "subtracts, or removes items from an array or string",
        token: '-',
        template: fragment!(
            "
            const {out:out} = sub({op1:in}, {op2:in});
            { inner }
        "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "times",
        description: "multiplies",
        token: '*',
        template: fragment!(
            "
            const {out:out} = mul({op1:in}, {op2:in});
            { inner }
        "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "div",
        description: "divides",
        token: '/',
        template: fragment!(
            "
            const {out:out} = div({op1:in}, {op2:in});
            { inner }
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "mod",
        description: "subtracts, or removes items from an array or string",
        token: '%',
        template: fragment!(
            "
            const {out:out} = mod({op1:in}, {op2:in});
            { inner }
        "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "equals",
        description: "performs a deep equals check",
        token: '=',
        template: fragment!(
            "
            const {out:out} = eq({op1:in}, {op2:in});
            { inner }
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "Unwrap",
        description: "Outputs each value from an array seperately",
        token: 'u',
        template: fragment!(
            "
            for (const {out:out} of iter({op1:in})){{
                { inner }
            }}
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "Dup",
        description: "Pops a value from the stack, then pushes it twice",
        token: ':',
        template: fragment!(
            "
            const {out1:out} = {value:in}, {out2:out} = {value:in};
            {inner}
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "Drop",
        description: "Pop a value from the stack",
        token: '~',
        template: fragment!(
            "
            {value:in};
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "Swap",
        description: "Pops two values from the stack then pushes them in reverse order",
        token: '$',
        template: fragment!(
            "
            // {value2:in}
            const [{out1:out},{out2:out}] = [{value1:in},{value2:in}];
            {inner}
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "Over",
        description: "Pops 2 values from the stack, pushes them back in order, then pushes the bottom most one again",
        token: '@',
        template: fragment!(
            "
            const [{out1:out},{out2:out},{out3:out}] = [{value2:in},{value1:in},{value2:in}];
            {inner}
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "List Sum",
        description: "Pops an array then outputs the sum of each element",
        token: 's',
        template: fragment!(
            "
            const {out:out} = iter({in:in}).reduce(add, null);
            {inner}
            "
        ),
        bracket_handlers: &[],
    },
    Builtin {
        name: "Generator Sum",
        description: "Sums the outputs of a generator",
        token: 'S',
        template: fragment!(
            "
            let {accumulator:local} = null;
            {inner}
            "
        ),
        bracket_handlers: &[BracketHandler {
            flags: BracketContextFlags::new(),
            output_handler: Some(OutputHandler {
                behavior: MultiOutputBehavior::FlattenAll,
                fragment: half_fragment!(
                    "
                            {accumulator:local} = add({accumulator:local}, {value:in});
                            "
                ),
            }),
            fragment: fragment!(
                "
                    const {out:out} = {accumulator:local};
                "
            ),
        }],
    },
    Builtin {
        name: "Array Index",
        description: "Gets the Nth element from a array",
        token: 'i',
        template: fragment!(
            "
            {out:out} = index({arr:in}, {index:in})
            "
        ),
        bracket_handlers: &[]
    },
    Builtin {
        name: "Generator Index",
        description: "Gets the Nth element from a generator",
        token: 'I',
        template: fragment!(
            "
            const {result:local} = generator_index(
                {index:in}, 
                ({generate:local})=>{{
                    {inner}
            "
        ),
        bracket_handlers: &[
            BracketHandler {
                flags: BracketContextFlags::new(),
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!("
                    if (({generate:local}({value:in}))) {{
                        return {value:in}
                    }}
                    "),
                    behavior: MultiOutputBehavior::FlattenAll
                }),
                fragment: fragment!("
                            //
                        }}
                    )

                    const {out:out} = {result:local};
                ")
            }
        ]
    },
    Builtin {
        name: "Array Zip",
        description: "Takes one element from each array",
        token: 'z',
        template: fragment!("
            {out:out} = array_zip({a:in}, {b:in});
        "),
        bracket_handlers: &[]
    },
    Builtin {
        name: "Flatten/Floor",
        description: "Floors numbers, flattens arrays",
        token: 'f',
        template: fragment!("
            {out:out} = flatten_floor({a:in});
        "),
        bracket_handlers: &[]
    },
    Builtin {
        name: "Iterator Zip",
        description: "Takes one element each from every frame of the generator",
        token: 'Z',
        template: fragment!("
            for ({var:local} of generator_zip(function* () {{
                {inner}
        "),
        bracket_handlers: &[
            BracketHandler {
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!("
                        yield [{value:in}];
                    "),
                    behavior: MultiOutputBehavior::HalfZip
                }),
                flags: BracketContextFlags::new(),
                fragment: fragment!("
                            //
                        }},
                        function* () {{
                            {inner}
                ")
            },
            BracketHandler {
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!("
                        yield [{value:in}];
                    "),
                    behavior: MultiOutputBehavior::Variadic
                }),
                flags: BracketContextFlags::new(),
                fragment: fragment!("
                            //
                        }},
                    )) {{
                        const [{it_var:out}] = {var:local};
                        {inner}
                    }}
                ")
            },
        ]
    },
    Builtin {
        name: "Multiple",
        description: "Takes a number as input, outputs the next value from the stack N times. Useful for filtering items.",
        token: 'm',
        template: fragment!("
            // {value:in}
            for (let {i:local}=0; {i:local}<{total:in}; {i:local}++) {{
                const {var:out} = {value:in};
                {inner}
            }}
        "),
        bracket_handlers: &[]
    },
    Builtin {
        name: "Modify",
        description: "Apply a modification to the top of the stack N times",
        token: 'M',
        template: fragment!("
            const {initial_value:local} = {initial_value:in};
            const {condition:local} = {condition:in};

            const {cb:local} = function* ({current_value:out}, {steps:local}) {{
                if (!to_bool({steps:local})) {{
                    yield {current_value:out};
                    return;
                }}
                {inner}
        "),
        bracket_handlers: &[
            BracketHandler {
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!("
                        yield* {cb:local} ({value:in}, decrement({steps:local}));
                    "),
                    behavior: MultiOutputBehavior::OnlyFirst
                }),
                flags: BracketContextFlags::new(),
                fragment: fragment!("
                        //
                    }};


                    for ({value:out} of {cb:local}({initial_value:local}, {condition:local})) {{
                        {inner}
                    }}
                ")
            },
        ]
    },
    Builtin {
        name: "Backwards",
        description: "Inverts numbers, reverses arrays",
        token: 'b',
        template: fragment!("
            {out:out} = backwards({a:in});
        "),
        bracket_handlers: &[]
    },
    Builtin {
        name: "Backwards",
        description: "Reverse the order of a generator",
        token: 'B',
        template: fragment!("
            const {arr:local} = []

            {inner}
        "),
        bracket_handlers: &[
            BracketHandler {
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!("
                        {arr:local}.push({value:in})
                    "),
                    behavior: MultiOutputBehavior::FlattenAll
                }),
                flags: BracketContextFlags::new(),
                fragment: fragment!("
                    for (let {i:local} = {arr:local}.length-1; {i:local}>=0; {i:local}-=1) {{
                        const {value:out} = {arr:local}[{i:local}];
                        {inner}
                    }}
                ")
            },
        ]
    },
    Builtin {
        name: "Array Count",
        description: "Get the length of an array",
        token: 'c',
        template: fragment!("
            {out:out} = count({a:in});
        "),
        bracket_handlers: &[]
    },
    
    Builtin {
        name: "Generator Count",
        description: "Find how many values a generator produces",
        token: 'C',
        template: fragment!("
            let {count:local} = 0

            {inner}
        "),
        bracket_handlers: &[
            BracketHandler {
                output_handler: Some(OutputHandler {
                    fragment: half_fragment!("
                        {count:local} += 1;
                    "),
                    behavior: MultiOutputBehavior::OnlyFirst
                }),
                flags: BracketContextFlags::new(),
                fragment: fragment!("
                    let {out:out} = {count:local};
                ")
            },
        ]
    },
];
